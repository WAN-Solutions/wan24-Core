<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>wan24-Core | wan24-Core </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="wan24-Core | wan24-Core ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="favicon.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    <meta property="docfx:newtab" content="true">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="wan24-core">wan24-Core</h1>

<p>This core library contains some .NET extensions and boiler plate avoiding
helpers. It's designed as core library for a long running process and
optimized for that purpose. The code tries to cache agressive whereever it's
possible. Types are designed to be thread-safe, if they're likely to be
accessed reading/writing from multiple threads (if it's their nature).
However, if it's not sure that a types nature is to manage multithreaded
access, performance goes before thread safety.</p>
<p>It started as a slender extension method collection and growed up to a larger
core utility until today. It's possible that some specialized parts will be
splitted into separate libraries in the future, if the core library is getting
too big - but the namespace will stay the same.</p>
<p>Some key features:</p>
<ul>
<li>Bootstrapping</li>
<li>Disposable base class for disposable types, which supports asynchronous
disposing
<ul>
<li>Dispose attribute for fields/properties which should be disposed
automatic when disposing</li>
</ul>
</li>
<li><code>CancellationOnDispose</code> cancels a cancellation token when an object is being
disposed (or another given cancellation token ws canceled)</li>
<li><code>Cancellations</code> combines multiple cancellation tokens into one</li>
<li>Type helper (type loading)</li>
<li>Secure byte and char array, which clears its contents when disposing</li>
<li>Pool rented array as disposable object (which optionally clears its contents
when disposing; for byte/char arrays just like the <code>Secure*Array</code>)</li>
<li>Asynchronous API helper
<ul>
<li>Asynchronous fluent API helper</li>
</ul>
</li>
<li>Byte array extensions
<ul>
<li>Endian conversion</li>
<li>Bit-converter (endian-safe)</li>
<li>UTF-8/16/32 (little endian) string decoding</li>
<li>Clearing</li>
</ul>
</li>
<li>Dictionary extensions
<ul>
<li>Merge with string key prefix</li>
<li>Merge a list with the index as key (and an optional key prefix)</li>
</ul>
</li>
<li>Char array extensions
<ul>
<li>Clearing</li>
</ul>
</li>
<li>Array helper extensions
<ul>
<li>Offset/length validation</li>
</ul>
</li>
<li>Array pool extensions
<ul>
<li>Renting a cleared array</li>
</ul>
</li>
<li>Enumerable extensions
<ul>
<li>Combine enumerables</li>
<li>Chunk enumerables</li>
</ul>
</li>
<li>Reflection extensions
<ul>
<li>Automatic parameter extension when invoking a method (with DI support)</li>
<li>Synchronous/asynchronous method invokation</li>
<li>Automatic constructor invokation using a given parameter set (with DI
support)</li>
<li>Nullability detection</li>
<li>Get property getter/setter delegates</li>
<li>Get cached field/property/method info</li>
</ul>
</li>
<li>Cache for field/property/method info and custom attributes</li>
<li>Delegate extensions
<ul>
<li>Delegate list invokation (with or without return values, with DI support)</li>
<li>Asynchronous delegate list invokation (with or without return values,
with DI support)</li>
</ul>
</li>
<li>Task extensions
<ul>
<li>Result getting of a generic task</li>
<li>Asynchronous task list awaiting</li>
<li>Shortcuts for await configurations</li>
<li>Shortcuts for starting a function as long running task</li>
<li>Shortcuts for starting a function as task with fair execution by the
scheduler</li>
<li>Add a cancellation token to a task (which can cancel the task awaiter)</li>
</ul>
</li>
<li>DI helper
<ul>
<li>Service provider adoption</li>
<li>DI object factory delegates</li>
<li>Asynchronous DI object factory delegates</li>
</ul>
</li>
<li>Enumeration extensions
<ul>
<li>Get enumeration value display string from <code>DisplayTextAttribute</code> or
using <code>ToString</code> (fallback)</li>
<li>Determine if all, any or which flags are contained in an enumeration
value</li>
<li>Remove flags of a mixed enumeration value</li>
<li>Get only flags of a mixed enumeration value</li>
<li>Value validation</li>
</ul>
</li>
<li>Number extensions
<ul>
<li>Determine if a type is a number</li>
<li>Determine if a number type is unsigned</li>
<li>Bit-converter (endian-safe)</li>
<li>Determine if a number (or any <code>IComparable</code>) is within a range</li>
</ul>
</li>
<li>Numeric bitwise extensions</li>
<li>Collection extensions
<ul>
<li>Add a range of items</li>
</ul>
</li>
<li>JSON helper
<ul>
<li>Exchangeable JSON encoder/decoder delegates (using <code>System.Text.Json</code>
per default)</li>
</ul>
</li>
<li>JSON extensions
<ul>
<li>Encode an object</li>
<li>Decode from a type</li>
<li>Decode a string</li>
</ul>
</li>
<li>Object extensions
<ul>
<li>Type conversion</li>
<li>Determine if a value is within a list of values</li>
</ul>
</li>
<li>String extensions
<ul>
<li>Get UTF-8/16/32 bytes (little endian)</li>
<li>Parsing</li>
</ul>
</li>
<li>Generic helper
<ul>
<li>Determine if two generic values are equal</li>
<li>Determine if a value is <code>null</code></li>
<li>Determine if a value is <code>default</code></li>
<li>Determine if a value is <code>null</code> or <code>default</code></li>
</ul>
</li>
<li><code>DateTime</code> extensions
<ul>
<li>Determine if a time is within a range</li>
<li>Determine if a time matches a reference time plus/minus an offset</li>
<li>Apply an offset to a time base on a reference time</li>
</ul>
</li>
<li><code>TimeSpanHelper</code>
<ul>
<li>Update a timeout</li>
</ul>
</li>
<li>Queue worker (for actions and/or items)</li>
<li>Parallel queue worker (for actions and/or items)</li>
<li><code>ParallelAsync</code> implementation
<ul>
<li><code>ForEachAsync</code> with an asynchronous or synchronous input source</li>
<li><code>FilterAsync</code> with an asynchronous or synchronous input source and item
filter</li>
<li><code>Filter</code> for synchronous parallel filtering</li>
</ul>
</li>
<li>Base class for a hosted worker, which implements the <code>IHostedService</code>
interface (timed or permanent running)</li>
<li><code>EventThrottle</code> for throttling event handler calls</li>
<li><code>ProcessThrottle</code> for throttling a processing channel</li>
<li><code>OrderedDictionary&lt;tKey, tValue&gt;</code> is used for working with indexed key/value
pairs</li>
<li><code>Timeout</code> will count down and raise an event, if not reset before reaching
the timeout</li>
<li><code>ILogger</code> support</li>
<li><code>IChangeToken</code> support using <code>ChangeCallback</code></li>
<li>Hierarchic configuration using <code>OverrideableConfig</code></li>
<li>Cancellation token awaiter</li>
<li><code>ObjectPool</code> for pooling objects (<code>DisposableObjectPool</code> for disposable
types), and <code>BlockingObjectPool</code> for a strict pool capacity limit</li>
<li><code>(Blocking)StreamPool</code>, <code>PooledMemoryStream</code>, <code>PooledTempFileStream</code> and
<code>PooledTempStream</code> (hosts written data in memory first)</li>
<li><code>ResetEvent</code> for (a)synchronous event waiting</li>
<li><code>LazyValue&lt;T&gt;</code>, <code>DisposableLazyValue&lt;T&gt;</code>, <code>AsyncDisposableLazyValue&lt;T&gt;</code> and
<code>TimeoutValue&lt;T&gt;</code> for lazy and timeout value serving</li>
<li><code>ObjectLockManager&lt;T&gt;</code> for asynchronous and awaitable object locking</li>
<li><code>Bitmap</code> for working with bits</li>
<li><code>DisposableWrapper&lt;T&gt;</code> for wrapping any (not disposable?) object with the
<code>IDisposable</code> and <code>IAsyncDisposable</code> interface using custom dispose actions
during runtime</li>
<li><code>DisposableAdapter</code> for adopting the <code>IDisposableObject</code> interface from a
type which can't extend the <code>DisposableBase</code> type</li>
<li>Generic object extenions for validating method arguments</li>
<li>CLI arguments interpreter</li>
<li>Runtime configuration from CLI arguments</li>
<li>Fast byte to string and string to byte encoding/decoding (using an URI
friendly charset, faster and smaller results than base64 encoding; charset is
customizable; encoded data integrity can be validated without decoding;
including extensions for numeric type encoding/decoding)</li>
<li>Collecting periodical statistical values</li>
<li>Streams
<ul>
<li><code>WrapperStream</code> wraps a base stream and provides <code>LeaveOpen</code></li>
<li><code>PartialStream</code> wraps a part of a base stream (read-only)</li>
<li><code>LengthLimitedStream</code> ensures a maximum stream length</li>
<li><code>MemoryPoolStream</code> uses an <code>ArrayPool&lt;byte&gt;</code> for storing written data</li>
<li><code>ThrottledStream</code> throttles reading/writing troughput</li>
</ul>
</li>
<li>Named mutex helper
<ul>
<li><code>GlobalLock</code> for a synchronous context</li>
<li><code>GlobalLockAsync</code> for an asynchronous context</li>
</ul>
</li>
<li>Retry helper which supports timeout, delay and cancellation</li>
<li>Asynchronous event</li>
</ul>
<h2 id="how-to-get-it">How to get it</h2>
<p>This library is available as
<a href="https://www.nuget.org/packages/wan24-Core/">NuGet package &quot;wan24-Core&quot;</a>.</p>
<h2 id="bootstrapping">Bootstrapping</h2>
<p>The <code>Bootstrapper.Async</code> method calls all static methods having the
<code>BootstrapperAttribute</code>. In order to be able to find the methods, it's
required to add the <code>BootstrapperAttribute</code> to the assembly.</p>
<p>You may also ad the <code>BootstrapperAttribute</code> to a type and/or the bootstrapper
method, in case the assembly contains multiple of them. In the assembly
attribute you need to set <code>ScanClasses</code> and/or <code>ScanMethods</code> to <code>true</code> in
order to perform a deep scanning during bootstrapping for performance reasons.</p>
<p>The bootstrapper methods may consume parameters which are available from the
DI helper. The method may be synchronous or asynchronous. The method can't be
defined in a generic class, and it can't be generic itself.</p>
<pre><code class="lang-cs">[assembly:Bootstrapper(typeof(YourBootstrapper),nameof(YourBootstrapper.BootstrapperMethod))]

public static class YourBootstrapper
{
    public static async Task BootstrapperMethod()
    {
        // Perform your bootstrapping here
    }
}

// Call the bootstrapper somewhere in your apps initialization code
await Bootstrap.Async();
</code></pre>
<p>The <code>BootstrapperAttribute</code> can be initialized with a numeric priority. The
bootstrapper will order the found bootstrapping methods by priority, where the
one with the highest number will be executed first (assembly and type
priorities count, too). At last there's a assembly location, type and method
name sorting. Bootstrapper methods will be executed sequential.</p>
<p>If you give a type and a method name to the assembly <code>BootstrapperAttribute</code>,
you won't need to add the attribute to the type and the method.</p>
<p>During bootstrapping, the cancellation token which was given to the
<code>Bootstrap.Async</code> method, can be injected to a bootstrappers method parameters.</p>
<p>After that bootstrapping was done, the <code>Bootstrap.AsyncBootstrapper</code> will be
called. At last the <code>Bootstrap.OnBootstrap</code> event will be raised.</p>
<p>During bootstrapping the <code>Bootstrap.IsBooting</code> property is <code>true</code>. After
bootstrapping the <code>Bootstrap.DidBoot</code> property is <code>true</code>.</p>
<p>The bootstrapper will load all referenced assemblies. If you load an assembly
later, it'll be bootstrapped automatic and added to the <code>TypeHelper</code> singleton
instance.</p>
<h2 id="type-helper">Type helper</h2>
<p>If you use the <code>TypeHelper.AddTypes</code> method, the unknown assemblies of the
added types will be added as searchable assemblies automatic.</p>
<p>You may attach to the <code>TypeHelper.OnLoadType</code> event for handling requests
more dynamic.</p>
<p>The <code>TypeHelper.GetType</code> method will try <code>Type.GetType</code> first and fall back to
the helper, if no type was found.</p>
<h2 id="di-helper">DI helper</h2>
<p>In order to make DI (dependency injection) working, you need to</p>
<ul>
<li>set a <code>DiHelper.ServiceProvider</code> and/or</li>
<li>add <code>DiHelper.(Async)ObjectFactories</code></li>
</ul>
<p>The <code>DiHelper.GetDiObjectAsync</code> method will try to resolve the request
synchronous, first. But the <code>DiHelper.GetDiObject</code> won't try asynchronous
object factories.</p>
<h2 id="mixed-enumeration-value">Mixed enumeration value</h2>
<p>A mixed enumeration contains X bits enumeration values, and Y bits flags:</p>
<pre><code class="lang-cs">[Flags]
public enum MixedEnum : int
{
    None = 0,
    Value1 = 1,
    Value2 = 2,
    Value3 = 3,
    ...
    Flag1 = 1 &lt;&lt; 8,
    Flag2 = 1 &lt;&lt; 9,
    FLAGS = Flag1 | Flag2 // Required to identify flags
}
</code></pre>
<p>The <code>FLAGS</code> value helps these extension methods to handle flag values:</p>
<pre><code class="lang-cs">MixedEnum value = MixedEnum.Value1 | MixedEnum.Flag1,
    valueOnly = value.RemoveFlags(),// == MixedEnum.Value1
    flagsOnly = value.OnlyFlags();// == MixedEnum.Flag1
</code></pre>
<h2 id="unsafe-code">Unsafe code</h2>
<p>The library uses unsafe code. If you don't want/need that, you can compile the
library with the <code>NO_UNSAFE</code> compiler constant to disable any unsafe
operation. Remember to unset the unsafe compiler option, too!</p>
<h2 id="disposable-base-class">Disposable base class</h2>
<p>The <code>DisposableBase</code> implements the <code>IDisposable</code> and <code>IAsyncDisposable</code>
interfaces. It provides some helpers and events, and also the
<code>DisposeAttribute</code>, which can be applied to fields and properties which you
wish to dispose automatic when disposing.</p>
<p>When your type derives from the <code>DisposableBase</code>, you'll need to implement the
abstract <code>Dispose</code> method:</p>
<pre><code class="lang-cs">protected override Dispose(bool disposing)
{
    // Your dispose logic here
}
</code></pre>
<p>There are measures to avoid that this method is being called twice.</p>
<p>To implement custom asynchronous disposing:</p>
<pre><code class="lang-cs">protected override async Task DisposeCore()
{
    // Your dispose logic here
}
</code></pre>
<p>In order to make the <code>DisposeAttribute</code> working, you have to call the
protected method <code>DisposeAttributes</code> or <code>DisposeAttributesAsync</code>.</p>
<p>The <code>IsDisposing</code> property value will be <code>true</code> as soon as the disposing
process started, and it will never become <code>false</code> again. The <code>IsDisposed</code>
property value will be <code>true</code> as soon as the disposing process did finish.</p>
<p><strong>TIP</strong>: Use the <code>DisposableBase&lt;T&gt;</code> base type, if you plan to use the
<code>DisposeAttribute</code>! This base class will cache the fields/properties once on
initialization to get rid of the reflection overhead which <code>DisposableBase</code>
requires for this feature.</p>
<p><strong>NOTE</strong>: The <code>DisposeAttribute</code> can be applied to <code>byte[]</code> and <code>char[]</code>, too,
which will simply call the <code>Clear</code> extension method on disposing. Another
<code>IEnumerable</code> will be enumerated for disposable items (recursing!).</p>
<h2 id="queue-worker">Queue worker</h2>
<pre><code class="lang-cs">using QueueWorker worker = new();
await worker.EnqueueAsync((ct) =&gt;
{
    // Do any background action here
});
</code></pre>
<p>The <code>QueueWorker</code> class can be extended as you need it.</p>
<p>The <code>ParallelQueueWorker</code> requires a number of threads in the constructor,
which defines the degree of parallelism, in which enqueued tasks will be
processed.</p>
<h2 id="queue-item-worker">Queue item worker</h2>
<pre><code class="lang-cs">using QueueItemWorker&lt;ItemType&gt; worker = new();
await worker.EnqueueAsync(new ItemType());
</code></pre>
<p>The <code>QueueItemWorker&lt;T&gt;</code> class can be extended as you need it.</p>
<p>The <code>ParallelItemQueueWorker&lt;T&gt;</code> requires a number of threads in the
constructor, which defines the degree of parallelism, in which enqueued items
will be processed.</p>
<h2 id="parallelasync"><code>ParallelAsync</code></h2>
<p>Using the .NET parallel implementation it's not possible to invoke
asynchronous item handlers. For this you can use the
<code>ParallelAsync.ForEachAsync</code> method, which uses a parallel item queue worker
in the background for asynchronous processing.</p>
<h2 id="hosted-worker">Hosted worker</h2>
<pre><code class="lang-cs">public class YourHostedWorker : HostedWorkerBase
{
    public YourHostedWorker() : base() { }

    protected override async Task WorkerAsync()
    {
        // Perform the service actions here
    }
}
</code></pre>
<p>The hosted worker implements the <code>IHostedService</code> interface and can be
extended as you need it.</p>
<h2 id="timed-hosted-worker">Timed hosted worker</h2>
<pre><code class="lang-cs">public class YourHostedWorker : TimedHostedWorkerBase
{
    public YourHostedWorker() : base(interval: 500) { }

    protected override async Task WorkerAsync()
    {
        // Perform the service actions here
    }
}
</code></pre>
<p>This example uses a 500ms timer. Based on the defined timer type, the interval
will be processed in different ways:</p>
<ul>
<li><code>Default</code>: Next worker run is now plus the interval (used by default)</li>
<li><code>Exact</code>: Next worker run is now plus the interval minus the processing
duration (used, if the start time of the processing is important)</li>
<li><code>ExactCatchingUp</code>: As <code>Exact</code>, but catching up missing processing runs
without delay, if a worker run duration exceeds the interval (used, if the
number of worker runs is important)</li>
</ul>
<p>Using the <code>SetTimerAsync</code> method you can change the timer settings at any
time. If you give the <code>nextRun</code> parameter, you may set a fixed next run time
(which won't effect the given interval, but just force the service to run at a
specific time for the next time).</p>
<p><strong>NOTE</strong>: The <code>nextRun</code> parameter will also force the service to (re)start!</p>
<p>By setting the property <code>RunOnce</code> to <code>true</code>, the service will stop after
running the worker once. In combination with the <code>SetTimerAsync</code> parameter
<code>nextRun</code> you can execute the worker at a specific time once.</p>
<p>The hosted worker implements the <code>IHostedService</code> interface and can be
extended as you need it.</p>
<h2 id="eventthrottle"><code>EventThrottle</code></h2>
<pre><code class="lang-cs">public class YourType : DisposableBase
{
    protected readonly YourEventThrottle EventThrottle;

    public YourType() : base() =&gt; EventThrottle = new(this);

    // This method will raise the OnEvent
    public void AnyMethod()
    {
        RaiseOnEventThrottled();
    }

    protected override Dispose(bool disposing) =&gt; EventThrottle.Dispose();

    // Delegate for OnEvent
    public delegate void YourTypeEvent_Delegate();
    // Event to throttle
    public event YourTypeEvent_Delegate? OnEvent;
    // Raise the OnEvent using the event throttle
    protected void RaiseOnEventThrottled() =&gt; EventThrottle.Raise();
    // Finally let the event handlers process the event
    protected void RaiseOnEvent() =&gt; OnEvent?.Invoke();

    // Event throttle implementation
    public class YourEventThrottle : EventThrottle
    {
        // Throttle the event handling down to max. one handling per 300ms
        public YourEventThrottle(YourType instance) : base(timeout: 300) =&gt; Instance = instance;

        public YourType Instance { get; }

        protected override HandleEvent(DateTime raised, int raisedCount)
        {
            Instance.RaiseOnEvent();
        }
    }
}
</code></pre>
<p>If <code>AnyMethod</code> is being called, the event will be forwarded to the event
throttle, which decides to throttle or raise the event. If <code>AnyMethod</code> was
called three times within 300ms, the first call will be executed in realtime,
while the 2nd and the 3rd call will be sqashed and executed once 300ms after
the 1st call was processed.</p>
<p>This example assumes you're working with a real event - but you may throttle
any event (which may not be a real event) using throttling logic.</p>
<h2 id="processthrottle"><code>ProcessThrottle</code></h2>
<pre><code class="lang-cs">public class YourProcessThrottle : ProcessThrottle
{
    // Throttle to processing one object per second
    public YourProcessThrottle() : base(limit: 1, timeout: 1000) { }

    // Processing API using a timeout
    public async Task&lt;int&gt; ProcessAsync(Memory&lt;bool&gt; items, TimeSpan timeout)
        =&gt; await ProcessAsync(items.Length, (count) =&gt; 
        {
            await Task.Yield();
            Span&lt;bool&gt; toProcess = items.Span[..count];
            items = items[count..];
            // Process toProcess
        }, timeout);

    // Processing API using a cancellation token
    public async Task&lt;int&gt; ProcessAsync(Memory&lt;bool&gt; items, CancellationToken token = default)
        =&gt; await ProcessAsync(items.Length, (count) =&gt; 
        {
            await Task.Yield();
            Span&lt;bool&gt; toProcess = items.Span[..count];
            items = items[count..];
            // Process toProcess
        }, token);
}
</code></pre>
<p>The example will throttle the processing to a maximum of one object per
second. Multiple threads may call <code>ProcessAsync</code> concurrent - processing will
be organized thread-safe.</p>
<p>The return value of <code>ProcessAsync</code> is the number of objects processed until
timeout or canceled.</p>
<p>The processing delegate shouldn't care about the timeout or if canceled and
just process the given number of objects.</p>
<p><strong>NOTE</strong>: A usage gap will slide the throttling timer. Example:</p>
<p>The timeout was set to 3 objects per 100ms. Now processing goes like this:</p>
<ul>
<li>First processed object on <code>0ms</code> will activate the throttling timeout</li>
<li>Next processed object on <code>10ms</code> will increase the object throttling counter</li>
<li>Next processed object on <code>110ms</code> will reset the throttling timeout and
counter (the usage gap of 100ms does exceed the timeout)</li>
<li>Next 2 processed objects on <code>120ms</code> will activate the throttle</li>
<li>Next object will have to wait until the throttle was released</li>
<li>The throttle will be released on <code>210ms</code>, which allows the last object to be
processed now</li>
</ul>
<p>In short words: The throttle timer will not reset in an fixed interval, but
the interval starts when processing items.</p>
<h2 id="change-token">Change token</h2>
<p>Implement by extending <code>ChangeToken</code>:</p>
<pre><code class="lang-cs">public class YourObservableType : ChangeToken
{
    public YourObservableType() : base()
    {
        ChangeIdentifier = () =&gt; HasChanged;
    }

    public bool HasChanged =&gt; ...;// Return if the object was changed

    public void ChangeAction()
    {
        // Perform changes
        InvokeCallbacks();
    }
}
</code></pre>
<p>Or by using a <code>ChangeToken</code> instance:</p>
<pre><code class="lang-cs">public class YourObservableType : IChangeToken
{
    public readonly ChangeToken ChangeToken;

    public YourObservableType() =&gt; ChangeToken = new(() =&gt; HasChanged);

    public bool HasChanged =&gt; ...;// Return if the object was changed

    public void ChangeAction()
    {
        // Perform changes
        ChangeToken.InvokeCallbacks();
    }

    // Implement the IChangeToken interface using our ChangeToken instance

    bool IChangeToken.HasChanged =&gt; ChangeToken.HasChanged;

    bool IChangeToken.ActiveChangeCallbacks =&gt; ChangeToken.ActiveChangeCallbacks;

    IDisposable IChangeToken.RegisterChangeCallback(Action&lt;object?&gt; callback, object? state)
        =&gt; ChangeToken.RegisterChangeCallback(callback, state);
}
</code></pre>
<h2 id="hierarchic-configuration">Hierarchic configuration</h2>
<p>Assume this configuration hierarchy:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Default values</td>
</tr>
<tr>
<td>2</td>
<td>User values (can override default values)</td>
</tr>
<tr>
<td>3</td>
<td>Administrator values (can override default/user values)</td>
</tr>
</tbody>
</table>
<p>In code:</p>
<pre><code class="lang-cs">public sealed class Config : OverrideableConfig&lt;Config&gt;
{
    public Config() : base()
    {
        SubConfig = new(this, new(this));// User values
        InitProperties();
    }

    private Config(Config parent, Config? sub = null) : base(parent)
    {
        if(sub != null)
        {
            SubConfig = sub;
            sub.ParentConfig = this;
            sub.SubConfig = new(sub);// Administrator values
        }
        InitProperties();
    }

    // A configuration value
    public ConfigOption&lt;string, Config&gt; AnyValue { get; private set; } = null!;

    private void InitProperties()
    {
        AnyValue = ParentConfig == null 
            // The master option has a default value
            ? new(this, nameof(AnyValue), canBeOverridden: true, &quot;default&quot;)
            // No default value for a sub-option
            : new(this, nameof(AnyValue));
    }
}

Config config = new(),
    user = config.SubConfig,
    admin = user.SubConfig;
</code></pre>
<p><strong>CAUTION</strong>: There's no endless-recursion protection for the <code>ParentConfig</code> or
the <code>SubConfig</code> properties!</p>
<p>Now users are able to override default values, and administrators are able to
override default and/or user values:</p>
<pre><code class="lang-cs">// Still the default value
Assert.AreEqual(&quot;default&quot;, config.AnyValue.FinalValue);

// User overrides the default value
user.AnyValue.Value = &quot;user&quot;;
Assert.AreEqual(&quot;default&quot;, config.AnyValue.Value);
Assert.AreEqual(&quot;user&quot;, config.AnyValue.FinalValue);

// Administrator overrides the user value
admin.AnyValue.Value = &quot;admin&quot;;
Assert.AreEqual(&quot;admin&quot;, config.AnyValue.FinalValue);

// User can't override the administrator value (but still store his own value 
// in case the administrator would unset his value)
user.AnyValue.Value = &quot;test&quot;;
Assert.AreEqual(&quot;admin&quot;, config.AnyValue.FinalValue);
Assert.AreEqual(&quot;test&quot;, user.AnyValue.Value);
</code></pre>
<p><strong>NOTE</strong>: Setting an option value is thread-safe.</p>
<p>It's also possible to flip the hierarchy:</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Default values</td>
</tr>
<tr>
<td>2</td>
<td>Administrator values (can define user visible and optional not overrideable values)</td>
</tr>
<tr>
<td>3</td>
<td>User values (can override overrideable values)</td>
</tr>
</tbody>
</table>
<p>Using this hierarchy an administrator could also allow or deny overriding
values at any time, for example.</p>
<p>The hierarchy depth isn't limited.</p>
<h2 id="object-locking">Object locking</h2>
<p>The <code>ObjectLockManager&lt;T&gt;</code> helps locking any object during an asynchronous
operation:</p>
<pre><code class="lang-cs">ObjectLock ol = await ObjectLockManager&lt;AnyType&gt;.Shared.LockAsync(anyObjectKey);
// A 2nd call to ObjectLockManager&lt;AnyType&gt;.Shared.LockAsync would block until the lock was released
await ol.RunTaskAsync(Task.Run(async () =&gt; 
{
    // Perform the asynchronous operation here
}));
// ol is disposed already, 'cause the asynchronous operation source task was awaited
// The next ObjectLockManager&lt;AnyType&gt;.Shared.LockAsync call will be processed now, if any
await ol.Task;// To throw any exception during performing the asynchronous operation
</code></pre>
<p>If <code>AnyType</code> implements the <code>IObjectKey</code> interface, it can be given to the
<code>ObjectLockManager&lt;T&gt;</code> methods as object argument.</p>
<p><strong>NOTE</strong>: <code>ObjectLock</code> will dispose itself as soon as <code>RunTaskAsync</code> has been
called, and the given task was completed.</p>
<h2 id="cli-arguments-interpreter">CLI arguments interpreter</h2>
<p>There a just a few rules:</p>
<ol>
<li>A flag starts with a single dash</li>
<li>A key for a value (list) starts with a double dash</li>
<li>Keys/values can be quoted using single or double quotes</li>
<li>Escape character is the backslash (only applicable in quoted values)</li>
<li>A quoted value must be escaped for JSON decoding, a backslash must be
double escaped</li>
<li>Double quotes in a quoted value must be escaped always</li>
</ol>
<p>Example:</p>
<p><code>&quot;-flag&quot; --key 'value1' value2 --key -value3 '--key2' &quot;value&quot;</code></p>
<p>For appending the value <code>-value3</code> to the value list of <code>key</code>, the value needs
to be added with another <code>--key</code> key identifier, 'cause it starts with a dash
and could be misinterpreted as a flag (which would result in a parser error).</p>
<p>A CLI app called with these arguments could interpret them easy using the
<code>CliArguments</code> class:</p>
<pre><code class="lang-cs">CliArguments cliArgs = new(args);
Assert.IsTrue(cliArgs[&quot;flag&quot;]);
Assert.AreEqual(3, cliArgs.All(&quot;key&quot;).Count);
Assert.AreEqual(&quot;value&quot;, cliArgs.Single(&quot;key2&quot;));
</code></pre>
<p>A <code>--</code> (double dash) may be interpreted as an empty key name or a flag with
the name <code>-</code>, based on if a value, which doesn't start with a dash, is
following. Examples:</p>
<ul>
<li><code>--</code>: <code>-</code> flag</li>
<li><code>-- -</code>: <code>-</code> flag (<code>--</code> and <code>-</code> are both interpreted as double <code>-</code> flag
(double flags will be combined))</li>
<li><code>-- value</code>: Empty key with the value <code>value</code></li>
<li><code>-- -key</code>: <code>-</code> and <code>key</code> flags</li>
</ul>
<p>Keyless arguments will be stored in the <code>KeyLessArguments</code> list - example:</p>
<pre><code class="lang-cs">CliArguments ca = CliArguments.Parse(&quot;value1 -flag value2 --key value3&quot;);
Assert.AreEqual(2, ca.KeyLessArguments.Count);
Assert.AreEqual(&quot;value1&quot;, ca.KeyLessArguments[0]);
Assert.AreEqual(&quot;value2&quot;, ca.KeyLessArguments[1]);
Assert.IsTrue(ca[&quot;flag&quot;]);
Assert.IsTrue(ca[&quot;key&quot;, true]);
</code></pre>
<h2 id="fast-byte---string-encodingdecoding">Fast byte &lt;-&gt; string encoding/decoding</h2>
<p>base64 is supported everywhere, but it's (relative) slow and produces too much
overhead, and uses also URI unfriendly characters. In addition it's also not
easy to validate base64, or to determine the encoded/decoded value length.</p>
<p>To fix all of these problems, the <code>ByteEncoding</code> class implements a fast
encoding, which uses only characters 0-9, a-z, A-Z, dash and underscore and
produces less overhead than base64. The encoded/decoded value length can be
calculated in advance, and it's fast and easy to detect errors in the encoded
data without having to decode it, first.</p>
<pre><code class="lang-cs">// In case you want to use a prepared output buffer
int encodedLen = anyByteArray.GetEncodedLength();

// Encoding
char[] encoded = anyByteArray.Encode();

// In case you want to use a prepared output buffer
int decodedLen = encoded.GetDecodedlength();

// Decoding
byte[] decoded = encoded.Decode();
</code></pre>
<p>Using extensions numeric values can be en-/decoded on the fly, too. The
special <code>EncodeNumberCompact</code> extension methods determine the smallest value
matching numeric type before encoding (use <code>DecodeCompactNumber</code> with the
original numeric type as generic argument for decoding).</p>
<p><strong>NOTE</strong>: Encoding an empty array results in an empty string. Encoding <code>0</code>
results in an empty string, too. Nothing encodes to nothing and decodes to
nothing, too.</p>
<p>If required, the used encoding character map can be customized. You may use
any 64 characters long map with unique items.</p>
<h2 id="string-parser">String parser</h2>
<p>Using the <code>Parse</code> extension method for a <code>string</code>, you can parse placeholders
into a string and modify the output using (customizable) parser functions:</p>
<pre><code class="lang-cs">Dictionary&lt;string, string&gt; data = new()
{
    {&quot;name&quot;, &quot;value&quot;}
};
Assert.AreEqual(&quot;value&quot;, &quot;%{name}&quot;.Parse(data));
</code></pre>
<p>You may setup the default parser data in <code>StringExtensions.ParserEnvironment</code>.
The given parser data will override defaults.</p>
<p>You can execute as many parser functions on the output as required, separated
using <code>:</code>:</p>
<p><code>%{input:func1:func2(param1,param2,...):func3():...}</code></p>
<p>The first optional segment is always a parser data variable name (if not used,
the sequence starts with a <code>:</code> to indicate a function call). A function may or
may not have parameters. The result of a function will be provided for the
next function. Available functions:</p>
<table>
<thead>
<tr>
<th>Function</th>
<th>Syntax</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>sub</code></td>
<td><code>%{input:sub([offset/length](,[length]))}</code></td>
<td>extracts a sub-string</td>
</tr>
<tr>
<td><code>left</code></td>
<td><code>%{input:left([length])}</code></td>
<td>takes X characters from the left</td>
</tr>
<tr>
<td><code>right</code></td>
<td><code>%{input:right([length])}</code></td>
<td>takes X characters from the right</td>
</tr>
<tr>
<td><code>trim</code></td>
<td><code>%{input:trim}</code></td>
<td>removes white-spaces from the value</td>
</tr>
<tr>
<td><code>discard</code></td>
<td><code>%{input:discard}</code></td>
<td>no parameters, discards the current output</td>
</tr>
<tr>
<td><code>escape_html</code></td>
<td><code>%{input:escape_html}</code></td>
<td>escapes the value for use within HTML</td>
</tr>
<tr>
<td><code>escape_json</code></td>
<td><code>%{input:escape_json}</code></td>
<td>escapes the value for use within double quotes (double quotes will be trimmed from the JSON result!)</td>
</tr>
<tr>
<td><code>escape_uri</code></td>
<td><code>%{input:escape_uri}</code></td>
<td>escapes the value for use within an URI</td>
</tr>
<tr>
<td><code>set</code></td>
<td><code>%{input:set([name])}</code> sets the current output as parser variable with the given name</td>
<td></td>
</tr>
<tr>
<td><code>var</code></td>
<td><code>%{:var([name])}</code> gets a parser data variable value</td>
<td></td>
</tr>
<tr>
<td><code>item</code></td>
<td><code>%{:item([index],[item/name](,[item](,...)))}</code> gets an item from a list (if using a variable name, its value will be splitted using pipe)</td>
<td></td>
</tr>
<tr>
<td><code>prepend</code></td>
<td><code>%{input:prepend([string])}</code></td>
<td>prepends a string</td>
</tr>
<tr>
<td><code>append</code></td>
<td><code>%{input:append([string])}</code></td>
<td>appends a string</td>
</tr>
<tr>
<td><code>insert</code></td>
<td><code>%{input:insert([index],[string])}</code></td>
<td>inserts a string at an index</td>
</tr>
<tr>
<td><code>remove</code></td>
<td><code>%{input:remove([offset/length](,[length]))}</code></td>
<td>removes a part (from the left)</td>
</tr>
<tr>
<td><code>concat</code></td>
<td><code>%{:concat([string],[string](,[string](...))}</code></td>
<td>concatenates strings</td>
</tr>
<tr>
<td><code>join</code></td>
<td><code>%{:join([separator],[string],[string](,...))}</code></td>
<td>joins strings</td>
</tr>
<tr>
<td><code>math</code></td>
<td><code>%{:math([operator],[value1],[value2](,...))}</code></td>
<td>performs math</td>
</tr>
<tr>
<td><code>rx</code></td>
<td><code>%{:rx([group_index]],[name/pattern])}</code></td>
<td>exchanges the parser regular expression and content group index for the next parser operations (the next round)</td>
</tr>
<tr>
<td><code>format</code></td>
<td><code>%{input:format([format])}</code></td>
<td>to format a numeric value</td>
</tr>
<tr>
<td><code>str_format</code></td>
<td><code>%{input:str_format(([value1](,...))}</code> to format the string value</td>
<td></td>
</tr>
<tr>
<td><code>insert_item</code></td>
<td><code>%{input:insert_item([index],[items_name])}</code></td>
<td>to insert an item (items will be splitted by pipe)</td>
</tr>
<tr>
<td><code>remove_item</code></td>
<td><code>%{input:remove_item([index])}</code></td>
<td>to remove an item (items will be splitted by pipe)</td>
</tr>
<tr>
<td><code>sort</code></td>
<td><code>%{input:sort((desc))}</code></td>
<td>to sort items</td>
</tr>
<tr>
<td><code>foreach</code></td>
<td><code>%{input:foreach([name])}</code></td>
<td>to parse a parser data value for each item (will be stored in <code>_item</code>)</td>
</tr>
<tr>
<td><code>if</code></td>
<td><code>%{input:if([name](,[name]))}</code></td>
<td>to parse a parser data value, if the value is <code>1</code> (else parse the second given parser data value)</td>
</tr>
<tr>
<td><code>split</code></td>
<td><code>%{input:split(prefix)}</code></td>
<td>to split items by pipe and set them as parser data using the prefix and appending the zero based item index</td>
</tr>
<tr>
<td><code>range</code></td>
<td><code>%{:range([start],[count])}</code></td>
<td>to create a numeric range</td>
</tr>
<tr>
<td><code>dummy</code></td>
<td><code>%{:dummy(...)}</code></td>
<td>does nothing (may be used as comment)</td>
</tr>
</tbody>
</table>
<p>Available math operators:</p>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Function</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>+</code></td>
<td>Summarize</td>
</tr>
<tr>
<td><code>-</code></td>
<td>Substract</td>
</tr>
<tr>
<td><code>*</code></td>
<td>Multiply</td>
</tr>
<tr>
<td><code>/</code></td>
<td>Divide</td>
</tr>
<tr>
<td><code>%</code></td>
<td>Modulo</td>
</tr>
<tr>
<td><code>a</code></td>
<td>Average</td>
</tr>
<tr>
<td><code>i</code></td>
<td>Minimum</td>
</tr>
<tr>
<td><code>x</code></td>
<td>Maximum</td>
</tr>
<tr>
<td><code>r</code></td>
<td>Round (2nd value is the number of decimals)</td>
</tr>
<tr>
<td><code>f</code></td>
<td>Floor</td>
</tr>
<tr>
<td><code>c</code></td>
<td>Ceiling</td>
</tr>
<tr>
<td><code>p</code></td>
<td>Y power of X (<code>double</code> conversion will be applied)</td>
</tr>
<tr>
<td><code>=</code></td>
<td>Equality (<code>0</code> is not equal, <code>1</code> if equal)</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Lower than (<code>0</code> is not lower, <code>1</code> if lower)</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than (<code>0</code> is not greater, <code>1</code> if greater)</td>
</tr>
<tr>
<td><code>s</code></td>
<td>Change the sign</td>
</tr>
</tbody>
</table>
<p>Numbers are written in invariant culture <code>float</code> style. <code>decimal</code> will be used
as number format.</p>
<p>To create a custom parser function:</p>
<pre><code class="lang-cs">StringExtensions[&quot;func_name&quot;] = (context) =&gt; 
{
    // Work with the StringParserContext and return the value to use or set context.Error for error handling
    return context.Value;
};
</code></pre>
<p>Example:</p>
<pre><code class="lang-cs">StringExtensions[&quot;upper&quot;] = (context) =&gt; context.Value.ToUpper();

Dictionary&lt;string, string&gt; data = new()
{
    {&quot;name&quot;, &quot;value&quot;}
};
Assert.AreEqual(&quot;VALUE&quot;, &quot;%{name:upper}&quot;.Parse(data));
</code></pre>
<p><strong>CAUTION</strong>: A placeholder must produce the same result, if it occurs
repeated! A repeated placeholder won't be parsed more than once, but being
replaced with the result of the first parsed placeholder.</p>
<p>Example:</p>
<pre><code class="lang-cs">Dictionary&lt;string, string&gt; data = new()
{
    {&quot;name&quot;, &quot;value&quot;}
};
string tmpl = &quot;%{name}%{name:len:set(name):discard}%{name}&quot;;
Assert.AreEqual(&quot;valuevalue&quot;, tmpl.Parse(data));
</code></pre>
<p>From the logic <code>value5</code> would be expected. To get <code>value5</code>, finally, you'll
have to modify the template:</p>
<p><code>%{name}%{name:len:set(name):discard}%{name:dummy}</code></p>
<p><strong>TIP</strong>: Almost all function parameters may be parser data variable names,
too, if they have a <code>$</code> prefix. To support that, use the <code>TryGetData</code> method
of the <code>StringParserContext</code>, if a parameter value starts with <code>$</code>.</p>
<p><strong>TIP</strong>: To ensure having all required parameters, use the
<code>EnsureValidParameterCount</code> of the <code>StringParserContext</code>. The method allows
you to define a number of allowed parameter counts (including zero) and
produces a common error message, if the function call syntax is wrong.</p>
<p><strong>TIP</strong>: A custom parser function may change the parser regular expression and
content group by changing <code>Rx</code> and <code>RxGroup</code>.</p>
<p>The string parser works recursive. To avoid an endless recursion, the default
parsing round count limit is 3. The current parsing round is accessable trough
the parser data <code>_round</code>. If a parser function parses a template, the called
parser will work in the current parsing round context and respect the limit,
too. Youmay set another default limit in <code>StringExtensions.ParserMaxRounds</code>.</p>
<p>The default behavior for errors is to throw an exception. If error throwing
was disabled, in case of an error a placeholder will stay in clear text, and a
function will return the unaltered value.</p>
<p>You may modify the placeholder declaration by setting another regular
expression to <code>StringExtensions.RxParser</code>. Group <code>$1</code> must contain the whole
placeholder, while group <code>$2</code> is required to contain the inner placeholder
contents (like variable name, function calls, parameters, etc.). There's no
way to customize the inner placeholder content syntax at present. You may also
give a custom regular expression to the <code>Parse</code> extension method, if you want
an isolated parsing. You can modify the inner content group index by setting
<code>StringExtensions.RxParserGroup</code> or giving <code>rxGroup</code> to the <code>Parse</code> methods.</p>
<p><strong>CAUTION</strong>: Be careful with customized parser functions: A mistake could let
a manipulated string harm your computer!</p>
<h2 id="retry-helper">Retry helper</h2>
<pre><code class="lang-cs">RetryInfo&lt;object&gt; result = await RetryHelper.TryActionAsync(
    async (currentTry, cancellation) =&gt; 
    {
        // Perform any critical action which may throw or timeout and return a value (or not)
    },
    maxNumberOfTries: 3,
    timeout: TimeSpan.FromSeconds(30),
    delay: TimeSpan.FromSeconds(3)
    );

// This will throw an exception, if failed, or return the action delegate return value, if succeed
object returnValue = result.ThrowIfFailed();
</code></pre>
<p><code>TryAction*</code> will try to execute an action for a maximum of N times, optional
having a total timeout, and optional performing a delay after a failed try.
The given action delegate may also return a value, which you can then find in
the <code>RetryInfo&lt;T&gt;.Result</code> property, if <code>Succeed</code> is <code>true</code>.</p>
<p>The <code>RetryInfo&lt;T&gt;</code> object contains some runtime informations:</p>
<ul>
<li>Start, done time and total runtime</li>
<li>Number of tries processed (a timeout or cancellation may throw before the
action is being called)</li>
<li>Catched exceptions during tries</li>
<li>If succeed, cancelled or timeout</li>
<li>The action delegate return value (if any)</li>
</ul>
<p><strong>NOTE</strong>: There's also a synchronous <code>TryAction</code> method, which supports
timeout and cancellation also.</p>
<h2 id="asynchronous-events">Asynchronous events</h2>
<pre><code class="lang-cs">// Example type using an asynchronous event
public class YourType
{
    public readonly AsyncEvent&lt;YourType, EventArgs&gt; OnYourEvent;

    public YourType() =&gt; OnYourEvent = new(this);

    public async Task RaiseOnYourEventAsync()
        =&gt; await ((IAsyncEvent&lt;YourType, EventArgs&gt;)OnYourEvent).RaiseEventAsync();
}

// An example asynchronous event listener
async Task eventListener(YourType sender, EventArgs e, CancellationToken ct)
{
    ...
}

// Attach to the event and raise it
YourType obj = new();
Assert.IsFalse(obj.OnYourEvent);
obj.OnYourEvent.Listen(eventListener);
Assert.IsTrue(obj.OnYourEvent);
await obj.RaiseOnYourEventAsync();

// Detach the event listener
obj.OnYourEvent.Detach(eventListener);
Assert.IsFalse(obj.OnYourEvent);
</code></pre>
<p>An <code>AsyncEvent&lt;tSender, tArgs&gt;</code> instance will only export public event
informations and functions like adding/removing event handlers, and if event
handlers are present. For raising the event, you need to use the
<code>RaiseEventAsync</code> methods which are available from the
<code>IAsyncEvent&lt;tSender, tArgs&gt;</code> interface.</p>
<p>Timeout, cancellation, synchronous and asynchronous event handlers are
supported. The <code>AsyncEvent&lt;tSender, tArgs&gt;</code> is designed to be thread-safe,
while multiple threads are allowed to raise the event in parallel.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/WAN-Solutions/wan24-Core/blob/dev/src/Wan24-Core Docs/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            (c) 2023 Andreas Zimmermann, wan24.de
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
